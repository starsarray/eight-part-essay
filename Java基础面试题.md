## 概念

### Java的特点：

- 平台无关性：可以将编译后的字节码文件在任何安装了JVM的系统上运行
- 面向对象：
- 内存管理：自动管理内存和回收不再使用的对象

### Java 的优势和劣势是什么？

**优势**：跨平台、强大的生态系统（Spring框架、各种库）、内存管理（减少了内存泄漏问题）、多线程支持（内置线程机制，方便并发）、有安全模型（沙箱机制）。

**劣势**：性能稍差（启动慢）、语法繁琐、内存消耗大（JVM本身占用内存）、面向对象过于严格（写简单程序反而麻烦）

### JVM、JRE、JDK三者关系？

- JVM是java虚拟机，Java程序运行的环境，提供了内存管理、垃圾回收、安全性等功能
- JRE是Java程序运行所需最小环境，包含JVM和一组Java类库
- JDK是java开发工具包，包含JVM、编译器（javac）、调试器等开发工具

### 为什么Java解释和编译都有？

java采用解释+JIT编译的混合模式，是一种智能权衡：

- 解释器保证跨平台性和快速启动
- JIT编译器保证长期运行的高性能
- 自适应优化根据程序实际行为动态调整

### Python和Java区别是什么？

- Java是一种已编译的编程语言，语法相对严格，执行效率高，多用于大型企业应用 、Android原生应用、高并发后端服务
- Python是一种解释语言，语法简洁，对cpu多核利用不佳，多用于数据科学、AI/机器学习、自动化脚本

###  值传递和引用传递的区别？

所有参数传递都是值传递（传递值的副本）

- 基本类型传递值的副本
- 引用类型传递引用的副本

## 数据类型

![img](https://cdn.xiaolincoding.com//picgo/1715930632378-7f03a5ae-3364-41d4-88a8-428997d543dd.png)

注意一下几点：

- 1字节（byte、boolean），2字节（short、char），4字节（int、float），8字节（long、double）
- 浮点数默认为double，末尾加f或F是float
- 包装类除了char是Character，int是Integer，其他都是首字母大写
- char是无符号，从0开始

#### 数据类型的转换方式有哪些？

- 自动类型转换（隐式转换）
- 强制类型转换（显示转换）：目标类型 变量名 = （目标类型）源类型
- 字符串转换：字符串转int用***Integer.parseInt()***
- 数值之间的转换：通过类型的包装类实现

### 类型互转会出现什么问题吗？

> 基本数据类型转换的问题

- 小范围转大范围数据类型没问题
- 大范围转小范围会有数据溢出、精度损失

> 对象引用转换的问题

- 向上转型（转换为父类）是自动、安全的
- 向下转型需要手动进行，存在风险。解决方式是用`instanceof`检查

### 为什么用bigDecimal 不用double ？

- double执行的是二进制浮点运算，表示只能用1/(2^n)的和的任意组合，但比如0.1不能精确表示，出现精度丢失问题
- Decimal 是精确计算，是十进制存储，运算都先转为整数运算，再调整小数位

### 装箱和拆箱是什么？

装箱（Boxing）和拆箱（Unboxing）是将基本数据类型和对应的包装类之间进行转换的过程

```java
Integer i = 10;  //装箱
int n = i;   //拆箱
```

自动装箱主要发生在**赋值**和**方法调用**的时候

- 赋值：int数据赋值给Integer变量
- 方法调用：int数据传入参数为Integer的函数

### 自动装箱的弊端

在一个循环中进行自动装箱操作就可能会创建多余的对象，Integer变量在执行`+`操作要先拆箱为int进行数值相加，然后把结果通过创建Integer对象保存下来，这样会创建大量无用的对象

### Java为什么要有Integer（对象封装）？

- 对象封装有很多好处，里面有很多方法用来专门处理该类型数据
- Java中大部分方法和类都是用来处理类类型对象
  - **泛型**只能用引用类型
  - 基本类型和**引用类型**不能直接转换，比如int转String不能直接转
  - **集合**只能存储对象，不能存储基本数据类型

### 说说Integer与int的优缺点

1. **功能丰富性**
   Integer 是对象，有方法（如进制转换、字符串解析），而 int 只能做基础运算
2. **null 值支持**
   Integer 可以表示“无值”状态（null），适合数据库字段、可选参数等场景
3. **泛型和集合兼容**
   Integer 能直接用于集合（如 List<Integer>）和泛型，int 需要装箱
4. **扩展性更强**
   作为对象，可以更好地集成到面向对象体系和框架中

**需要注意的 trade-off：**

   - **内存开销**：Integer 对象比 int 占用更多内存
   - **性能影响**：频繁装箱/拆箱会影响性能
   - **比较陷阱**：要用 equals() 比较值，而非 ==（缓存范围外）

### 说一下 Integer的缓存

Integer 缓存是 Java 对常用数值的对象复用优化。默认缓存 -128 到 127 的 Integer 对象，通过 Integer.valueOf() 或自动装箱触发。这能减少内存分配，但要注意比较时应使用 equals()，因为超出缓存范围或通过 new 创建的对象，即使值相同，引用也不同。缓存上限可通过 JVM 参数 AutoBoxCacheMax 调整。

## 面向对象

### 怎么理解面向对象？简单说说封装继承多态

- 封装：封装是指将对象的属性（数据）和行为（方法）结合在一起，对外隐藏对象的内部细节，仅通过对象提供的接口与外界交互。封装的目的是增强安全性和简化编程，使得对象更加独立。
- 继承：是一种可以让子类共享父类的数据结构和方法的机制，建立了类与类之间的层次关系，让结构更加清晰。
- 多态：指能够让不同类的对象对同一消息做出响应，让代码编写更加灵活，扩展性更好。

### 多态体现在哪几个方面？

- **编译时多态（方法重载）**：同一个类中多个方法同名但参数列表不同，编译器根据调用时的参数类型和数量决定具体调用哪个方法。
- **运行时多态（方法重写）**：子类重写父类方法，当父类引用指向子类对象时，调用方法会动态绑定到子类的实现。
- **接口多态（接口实现）**：不同类实现同一接口，通过接口引用调用方法时，实际执行的是各个实现类的具体逻辑。
- **抽象类多态（抽象方法）**：继承抽象类的子类必须实现其抽象方法，通过抽象类引用调用时执行子类的具体实现。

### 多态解决了什么问题？

多态主要解决了 **代码的扩展性、可维护性和复用性** 问题，具体体现在：

1. **降低耦合，提高灵活性**
   允许程序面向抽象（接口/父类）编程，而不是具体实现。当需要扩展新功能时，只需增加新的子类，无需修改原有代码，符合 **开闭原则**。
2. **减少重复代码，提高复用性**
   通过同一接口操作不同类型对象，避免为每个具体类型编写相似代码。例如，一个 `draw()` 方法可以绘制圆形、矩形等多种图形，而不需要为每个图形写独立调用逻辑。
3. **增强可读性和可维护性**
   用统一的方式处理一组相关对象，使代码更简洁清晰。例如集合排序 `Collections.sort()` 可以对任何实现 `Comparable` 的对象排序，无需为每种类型写排序逻辑。
4. **支持设计模式的实现**
   工厂模式、策略模式、模板方法模式等经典设计模式都依赖多态实现，提升系统架构的弹性。

### 面向对象的设计原则你知道有哪些吗

1. **单一职责原则 (SRP)**
   一个类只应有一个引起变化的原因，即一个类只负责一项明确的功能。
2. **开闭原则 (OCP)**
   软件实体应对扩展开放，对修改关闭。通过抽象和继承实现功能扩展，避免修改原有代码。
3. **里氏替换原则 (LSP)**
   子类必须能够完全替换其父类，且不影响程序的正确性。子类可以扩展功能，但不能改变父类的原有行为。
4. **接口隔离原则 (ISP)**
   客户端不应被迫依赖它不需要的接口。应将大接口拆分为更小、更具体的接口。
5. **依赖倒置原则 (DIP)**
   高层模块不应依赖低层模块，二者都应依赖抽象。抽象不应依赖细节，细节应依赖抽象。
6. **迪米特法则（最少知识原则）**
   一个对象应尽可能少地了解其他对象，降低类之间的耦合度。
7. **合成复用原则**
   优先使用组合/聚合，而不是继承来达到复用的目的，提高代码的灵活性。

### 重载与重写有什么区别？

重载是指在同一个类中定义多个同名方法，重写是指子类重写父类的方法

### 抽象类和普通类区别？

- 实例化:普通类可以直接实例化对象，而抽象类不能被实例化，只能被继承。
- 方法实现:普通类中的方法可以有具体的实现，而抽象类中的方法可以有实现也可以没有实现。
- 继承:一个类可以继承一个普通类，而且可以继承多个接口;而一个类只能继承一个抽象类，但可以同时实现多个接口。
- 实现限制:普通类可以被其他类继承和使用，而抽象类一般用于作为基类，被其他类继承和扩展使用。

### Java抽象类和接口的区别是什么？

1. **设计理念不同**
   抽象类表示"是什么"（is-a关系），是对类本质的抽象；接口表示"能做什么"（has-a关系），是对行为能力的抽象。
2. **定义方式不同**
   抽象类使用`abstract class`声明；接口使用`interface`声明。
3. **继承与实现方式不同**
   抽象类通过`extends`继承，Java中是单继承；接口通过`implements`实现，支持多实现。
4. **成员变量不同**
   抽象类可以包含普通成员变量、静态变量、常量；接口只能包含`public static final`常量（默认修饰符可省略）。
5. **构造方法不同**
   抽象类可以有构造方法（供子类调用初始化）；接口不能有构造方法。
6. **方法实现不同**
   抽象类可以有抽象方法和具体方法；接口在Java 8之前只能有抽象方法，Java 8及以后可以有默认方法（default）和静态方法。
7. **访问修饰符不同**
   抽象类的方法可以有各种访问修饰符；接口的方法默认是public，且不能是private（Java 9前）或protected。

### 抽象类能加final修饰吗？

不能，Java中的抽象类是用来被继承的，而final修饰符用于禁止类被继承或方法被重写，因此，抽象类和final修饰符是互斥的，不能同时使用。

### 接口里面可以定义哪些方法？

- 抽象方法（Java 8之前）：默认是 public 和 abstract，这些修饰符可以省略。
- 默认方法（Java 8引入）：允许接口提供具体实现。实现类可以选择重写默认方法。
- 静态方法（Java 8引入）：属于接口本身，可以通过接口名直接调用，而不需要实现类的对象。
- 私有方法（Java 9引入）：用于在接口中为默认方法或其他私有方法提供辅助功能。这些方法不能被实现类访问，只能在接口内部使用。

### 抽象类可以被实例化吗？

抽象类本身不能被实例化，但通过继承抽象类并实现所有抽象方法的子类是可以被实例化的。

### 接口可以包含构造函数吗？

构造函数就是初始化class的属性或者方法，在new的时候自动调用，但接口都不能new，也就不需要

### 解释Java中的静态变量和静态方法

都是与类本身关联的，而不是与类的实例（对象）关联。它们在内存中只存在一份，可以被类的所有实例共享。

**静态变量特点：**

- **共享性**：所有该类的实例共享同一个静态变量。如果一个实例修改了静态变量的值，其他实例也会看到更改
- **初始化**：静态变量在类被加载时初始化，只会对其进行一次分配内
- **访问方式**：静态变量可以直接通过类名访问，也可以通过实例访问，但推荐使用类名

**静态方法特点：**

- **无实例依赖**：静态方法可以在没有创建类实例的情况下调用。对于静态方法来说，不能直接访问非静态的成员变量或方法，因为静态方法没有上下文的实例
- **访问静态成员**：静态方法可以直接调用其他静态变量和静态方法，但不能直接访问非静态成员
- **多态性**：静态方法不支持重写（Override），但可以被隐藏（Hide）

> 使用场景

- **静态变量**：常用于需要在所有对象间共享的数据，如计数器、常量等
- **静态方法**：常用于助手方法、获取类级别的信息或者是没有依赖实例的数据处理

### 非静态内部类和静态内部类的区别？

- 非静态内部类依赖于外部类的实例，而静态内部类不依赖于外部类的实例
- 非静态内部类可以访问外部类的实例变量和方法，而静态内部类只能访问外部类的静态成员
- 非静态内部类不能定义静态成员，而静态内部类可以定义静态成员
- 非静态内部类在外部类实例化后才能实例化，而静态内部类可以独立实例化
- 非静态内部类可以访问外部类的私有成员，而静态内部类不能直接访问外部类的私有成员，需要通过实例化外部类来访问

### 非静态内部类可以直接访问外部方法，编译器是怎么做到的？

编译器在生成字节码时会为非静态内部类维护一个指向外部类实例的引用，在生成非静态内部类的构造方法时，将外部类实例作为参数传入，并在内部类的实例化过程中建立外部类实例与内部类实例之间的联系，从而实现直接访问外部方法的功能。

## 关键字

### Java 中 final 作用是什么？

`final`关键字主要有以下三个方面的作用：用于修饰类、方法和变量。

- 修饰类：当`final`修饰一个类时，表示这个类不能被继承，是类继承体系中的最终形态。例如，Java 中的`String`类就是用`final`修饰的。
- 修饰方法：用`final`修饰的方法不能在子类中被重写。比如，`java.lang.Object`类中的`getClass`方法就是`final`的，因为这个方法的行为是由 Java 虚拟机底层实现来保证的，不应该被子类修改。
- 修饰变量：当`final`修饰基本数据类型的变量时，该变量一旦被赋值就不能再改变。对于引用数据类型，`final`修饰意味着这个引用变量不能再指向其他对象，但对象本身的内容是可以改变的。

### Java 中 static的作用是什么？

`static` 关键字主要用于修饰类的成员（变量、方法、代码块）和内部类，其核心作用是**将成员与类本身关联，而非与类的实例（对象）关联**。

- 修饰变量：通过 `类名.变量名` 直接访问，无需创建对象，通常用于存储所有对象共享的数据，如常量、计数器等。
- 修饰方法：通过 `类名.方法名`调用，通常用于工具类方法（如 `Math.random()`）、工厂方法等。
- 修饰代码块：静态代码块在**类加载时执行**，且只执行一次（先于对象构造方法），用于初始化静态变量或执行类级别的预处理操作。
- 修饰内部类：静态内部类不依赖于外部类的实例，可以独立存在，**不能直接访问外部类的非静态成员**

## 深拷贝和浅拷贝

### 深拷贝和浅拷贝的区别？

- 浅拷贝是指只复制对象本身和其内部的值类型字段，但不会复制对象内部的引用类型字段。
- 深拷贝是指在复制对象的同时，将对象内部的所有引用类型字段的内容也复制一份，而不是共享引用。

### 实现深拷贝的三种方法是什么？

1. **实现Cloneable接口并重写clone方法**
   通过实现`Cloneable`接口，重写`Object.clone()`方法，对对象的所有引用类型属性调用克隆方法，实现完全的深拷贝。
2. **使用序列化/反序列化**
   将对象序列化为字节流，再从字节流反序列化生成新对象。要求所有涉及的对象都必须实现`Serializable`接口。
3. **使用拷贝构造方法或工厂方法**
   在类中定义专门的构造方法或静态工厂方法，手动创建新对象并复制所有字段，对引用类型字段创建新的实例。

## 泛型

### 什么是泛型？

允许类、接口和方法在定义时使用一个或多个类型参数，这些类型参数在使用时可以被指定为具体的类型。

> 为什么需要泛型？

- 适用于多种数据类型执行相同代码
- 泛型中的类型在使用时指定，不需要强制类型转换（类型安全）

## 对象

### java创建对象有哪些方式？

- **使用new关键字**：通过调用类的构造器来实例化对象，实现简单，但需要知道具体类名。
- **使用Class类的newInstance()方法**（JDK9后过时）：通过 Java 的反射 API，在运行时动态地创建对象。在 JDK 9 后被标记为过时，因为它只能调用无参公有构造器，且会抛出所有异常。
- **使用Constructor类的newInstance()方法**：同样是通过反射机制，可以使用Constructor类的newInstance()方法创建对象。
- **使用clone()方法**：通过实现 `Cloneable` 接口并重写 `Object` 类的 `clone()` 方法，可以基于一个现有对象（原型）创建一个新的副本对象。
- **使用反序列化**：通过 `ObjectInputStream` 从一个字节流（通常是文件或网络）中重建一个对象。不会调用类的任何构造器，类必须实现 `java.io.Serializable` 接口。
- **使用工厂模式**：这是一种设计模式，不直接使用 `new`，而是通过一个方法来返回对象实例。`getInstance()`、`valueOf()` 等都是常见的工厂方法。将对象的创建与使用分离，降低耦合，还可以隐藏创建对象的复杂逻辑（如池化技术、缓存）。

### New出的对象什么时候回收？

通过过关键字`new`创建的对象，由Java的垃圾回收器（Garbage Collector）负责回收，主要有以下几种情况：

1. 引用计数法：某个对象的引用计数为0时，表示该对象不再被引用，可以被回收。
2. 可达性分析算法：从根对象（如方法区中的类静态属性、方法中的局部变量等）出发，通过对象之间的引用链进行遍历，如果存在一条引用链到达某个对象，则说明该对象是可达的，反之不可达，不可达的对象将被回收。
3. 终结器（Finalizer）：如果对象重写了`finalize()`方法，垃圾回收器会在回收该对象之前调用`finalize()`方法，对象可以在`finalize()`方法中进行一些清理操作。然而，终结器机制的使用不被推荐，因为它的执行时间是不确定的，可能会导致不可预测的性能问题。

### 如何获取私有对象？

一般只能在所在类的内部被访问，但可以通过公共访问器（getter方法）或者反射获取。

##  反射

### 什么是反射？

反射是 Java 提供的动态机制，允许程序在**运行时**获取类的内部信息（如方法、字段、构造方法等），并能够动态操作这些成员。

反射具有以下特性：

1. **运行时类型检查**
   动态获取类的名称、父类、接口、注解等信息。
2. **动态创建对象**
   即使编译时不知道具体类名，也能在运行时实例化对象。
3. **动态调用方法**
   运行时根据方法名和参数调用任意方法。
4. **动态操作字段**
   可以读取或修改对象的字段值（包括私有字段）。

### 反射在你平时写代码或者框架中的应用场景有哪些?

- **加载数据库驱动**：项目底层数据库有时是用MySQL，有时用Oracle，需要动态地根据实际情况加载驱动类。
- **配置文件加载**：通过反射根据配置文件中指定的类名动态创建对象，实现灵活配置。
- **框架开发**：如Spring的依赖注入、Hibernate的ORM映射，都通过反射实现对象创建和属性填充。
- **动态代理**：AOP实现中通过反射创建代理对象，拦截并增强方法调用。
- **序列化与反序列化**：JSON/XML工具通过反射读取对象字段进行序列化，或根据字段名设置值进行反序列化。
- **单元测试**：通过反射调用私有方法或修改私有字段，以进行更全面的测试。
- **注解处理**：扫描并处理自定义注解，如根据注解生成代码或执行特定逻辑。
- **插件化架构**：动态加载外部JAR包中的类，实现功能扩展。

## 注解

### 能讲一讲Java注解的原理吗？

注解本质是一个继承了Annotation的特殊接口，其具体实现类是Java运行时生成的动态代理类。

我们通过反射获取注解时，返回的是Java运行时生成的动态代理对象。通过代理对象调用自定义注解的方法，会最终调用AnnotationInvocationHandler的invoke方法。该方法会从memberValues这个Map中索引出对应的值，而memberValues中的数据是在类加载时从class文件的注解信息中解析并缓存得到的。

### 对注解解析的底层实现了解吗？

注解解析底层通过`AnnotationParser`读取class文件中的二进制注解数据，按需解析并缓存在Class对象中。当调用`getAnnotation()`时，通过动态代理生成`AnnotationInvocationHandler`作为注解接口的实现，其`invoke()`方法返回预先解析的属性值。整个过程采用懒加载和缓存优化，确保高效的类型安全访问。

### Java注解的作用域呢？

1. **类/接口级别（TYPE）**
   用于类、接口、枚举或注解类型本身。例如：`@Component`、`@Service`
2. **字段级别（FIELD）**
   用于类的成员变量。例如：`@Autowired`、`@Value`
3. **方法级别（METHOD）**
   用于方法定义。例如：`@Override`、`@GetMapping`
4. **参数级别（PARAMETER）**
   用于方法或构造函数的参数。例如：`@RequestParam`、`@PathVariable`
5. **构造函数级别（CONSTRUCTOR）**
   用于构造函数。例如：`@Autowired`（构造器注入）
6. **局部变量级别（LOCAL_VARIABLE）**
   用于方法内的局部变量（较少使用）
7. **注解类型级别（ANNOTATION_TYPE）**
   用于其他注解上（元注解）。例如：`@Target`、`@Retention`自身
8. **包级别（PACKAGE）**
   用于包声明。例如：`package-info.java`中的注解

**Java 8新增：**

9. **类型参数级别（TYPE_PARAMETER）**

​	用于泛型类型参数。例如：`class MyClass<@MyAnnotation T>`

10. **类型使用级别（TYPE_USE）**
    用于任何使用类型的地方。例如：类型转换、instanceof检查、泛型类型参数等

## 异常

### 介绍一下Java异常

![img](https://cdn.xiaolincoding.com//picgo/1720683900898-1d0ce69d-4b5d-41a6-a5df-022e42f8f4c5.webp)

```java
Throwable
├── Error（错误：系统级严重问题，程序通常无法处理）
│   ├── OutOfMemoryError（内存溢出）
│   ├── StackOverflowError（栈溢出）
│   └── VirtualMachineError（虚拟机错误）
│
└── Exception（异常：程序可以处理的非正常情况）
    ├── RuntimeException（运行时异常/非受检异常）
    │   ├── NullPointerException（空指针）
    │   ├── ArrayIndexOutOfBoundsException（数组越界）
    │   ├── ClassCastException（类型转换）
    │   └── IllegalArgumentException（非法参数）
    │
    └── 其他Exception（受检异常）
        ├── IOException（IO异常）
        ├── SQLException（数据库异常）
        └── FileNotFoundException（文件未找到）
```

Java 的异常体系主要基于 `Throwable` 及其子类。`Throwable` 有两个重要的子类：`Error` 和 `Exception`，它们分别代表了不同类型的异常情况。

1. **`Error` (错误)**： 表示运行环境的错误，错误是程序无法处理的严重问题，如虚拟机错误、动态链接库失效等。程序不应该尝试捕获这类错误。例如，`OutOfMemoryError`、`StackOverflowError` 等。
2. `Exception` (异常)： 表示程序本身可以处理的异常情况。异常分为两大类：
   - **非运行时异常（受检异常，Checked Exception）**： 这类异常在编译时就必须被捕获或者声明抛出。它们通常是外部错误，如文件不存在 (`FileNotFoundException`)、类未找到 (`ClassNotFoundException`) 等。非运行时异常强制程序员处理这些可能出现的问题，增强了程序的健壮性。
   - **运行时异常（非受检异常，Unchecked Exception 或 RuntimeException）**： 这类异常特指 `RuntimeException` 及其子类。它与 `Error` 一起构成了 Java 中的**非受检异常**家族。运行时异常由程序逻辑错误导致，如空指针访问 (`NullPointerException`)、数组越界 (`ArrayIndexOutOfBoundsException`) 等。运行时异常是不需要在编译时强制捕获或声明的。

### Java异常处理有哪些？

- try-catch-finally语句块：用于捕获并处理可能抛出的异常。try块中包含可能抛出异常的代码，catch块用于捕获并处理特定类型的异常。可以有多个catch块来处理不同类型的异常。finally块用于定义无论是否发生异常都会执行的代码块。通常用于释放资源，确保资源的正确关闭。
- throw语句：用于手动抛出异常。可以根据需要在代码中使用throw语句主动抛出特定类型的异常。

- throws关键字：用于在方法声明中声明可能抛出的异常类型。如果一个方法可能抛出异常，但不想在方法内部进行处理，可以使用throws关键字将异常传递给调用者来处理。

### 抛出异常为什么不用throws？

如果异常是未检查异常或者在方法内部被捕获和处理了，那么就不需要使用throws。

- **Unchecked Exceptions**：未检查异常（unchecked exceptions）是继承自RuntimeException类或Error类的异常，**编译器不强制要求进行异常处理**。因此，对于这些异常，不需要在方法签名中使用throws来声明。示例包括NullPointerException、ArrayIndexOutOfBoundsException等。
- **捕获和处理异常**：另一种常见情况是，在方法内部捕获了可能抛出的异常，并在方法内部处理它们，而不是通过throws子句将它们传递到调用者。这种情况下，方法可以处理异常而无需在方法签名中使用throws。

### try{return “a”} finally{return “b”}这条语句返回啥

finally块中的return语句会覆盖try块中的return返回，因此，该语句将返回"b"。

## object

### **Object类有哪些方法？**

Object类是Java中所有类的超类，每个类都直接或间接继承Object类。它定义了以下11个方法：


#### **1. 基本信息获取**

- **`Class<?> getClass()`**
  返回对象的运行时类（Class对象），用于反射。
- **`int hashCode()`**
  返回对象的哈希码值，用于哈希表（如HashMap）。
- **`String toString()`**
  返回对象的字符串表示，默认格式为`类名@哈希码`。

#### **2. 对象比较**

- **`boolean equals(Object obj)`**
  判断两个对象是否相等，默认比较对象地址（与==相同）。

#### **3. 对象克隆**

- **`protected Object clone() throws CloneNotSupportedException`**
  创建并返回对象的副本（浅拷贝），需要实现Cloneable接口。

#### **4. 线程同步（多线程相关）**

- **`final void wait()`**
  使当前线程等待，直到另一个线程调用此对象的`notify()`或`notifyAll()`。
- **`final void wait(long timeout)`**
  使当前线程等待指定的毫秒数。
- **`final void wait(long timeout, int nanos)`**
  使当前线程等待指定的毫秒+纳秒数。
- **`final void notify()`**
  唤醒在此对象监视器上等待的单个线程。
- **`final void notifyAll()`**
  唤醒在此对象监视器上等待的所有线程。

#### **5. 垃圾回收**

- **`protected void finalize() throws Throwable`**
  当垃圾回收器确定该对象不再被引用时调用（Java 9后已废弃）。

### == 与 equals 有什么区别？

#### **1. 基本数据类型（8种：int、char等）**

- **`==`**：比较**值**是否相等
- **`equals()`**：不存在，基本类型没有方法

#### **2. 普通对象（未重写equals）**

- **`==`**：比较**内存地址**是否相同（是否同一个对象）
- **`equals()`**：默认与`==`相同，比较**内存地址**

#### **3. String字符串**

- **`==`**：比较**内存地址**
  - 字面量赋值：如果字符串常量池已存在，则复用同一对象
  - `new String()`：创建新对象，地址不同
- **`equals()`**：比较**内容**（字符序列）是否相同

#### **4. 包装类型（Integer、Long等）**

- **`==`**：比较**内存地址**
  - 注意：-128~127有缓存，相同值可能指向同一对象
  - 超出范围或`new`创建的都是新对象
- **`equals()`**：比较**包装的基本值**是否相等

#### **5. 枚举类型（Enum）**

- **`==`**：比较**内存地址**（枚举常量是单例，相同枚举值地址相同）
- **`equals()`**：通常与`==`结果相同，但建议用`==`（更高效）

#### **6. 数组**

- **`==`**：比较**内存地址**（是否同一个数组对象）
- **`equals()`**：默认与`==`相同，未重写，比较**内存地址**

### hashcode和equals方法有什么关系？

在 Java 中，对于重写 `equals` 方法的类，通常也需要重写 `hashCode` 方法，并且需要遵循以下规定：

- **一致性**：如果两个对象使用 `equals` 方法比较结果为 `true`，那么它们的 `hashCode` 值必须相同。也就是说，如果 `obj1.equals(obj2)` 返回 `true`，那么 `obj1.hashCode()` 必须等于 `obj2.hashCode()`。
- **非一致性**：如果两个对象的 `hashCode` 值相同，它们使用 `equals` 方法比较的结果不一定为 `true`。即 `obj1.hashCode() == obj2.hashCode()` 时，`obj1.equals(obj2)` 可能为 `false`，这种情况称为哈希冲突。

### java 里 string的常用方法有哪些？

#### **1. 字符串长度与判空**

- `length()` - 返回字符串长度
- `isEmpty()` - 判断字符串是否为空（长度为0）
- `isBlank()` - 判断字符串是否为空或只包含空白字符（Java 11+）

#### **2. 查找与定位**

- `charAt(int index)` - 返回指定索引处的字符
- `indexOf(String str)` - 返回指定子字符串第一次出现的索引
- `lastIndexOf(String str)` - 返回指定子字符串最后一次出现的索引
- `contains(CharSequence s)` - 判断是否包含指定字符序列

#### **3. 比较与判断**

- `equals(Object obj)` - 比较字符串内容是否相等
- `equalsIgnoreCase(String str)` - 忽略大小写比较
- `startsWith(String prefix)` - 判断是否以指定前缀开头
- `endsWith(String suffix)` - 判断是否以指定后缀结尾
- `compareTo(String str)` - 按字典顺序比较字符串

#### **4. 截取与拆分**

- `substring(int beginIndex)` - 从指定位置截取到末尾
- `substring(int beginIndex, int endIndex)` - 截取指定范围的子串
- `split(String regex)` - 根据正则表达式拆分字符串
- `split(String regex, int limit)` - 限制拆分次数

#### **5. 大小写转换**

- `toLowerCase()` - 转换为小写
- `toUpperCase()` - 转换为大写

#### **6. 去除空白**

- `trim()` - 去除字符串两端空白字符（空格、制表符等）
- `strip()` - 去除两端空白字符（Java 11+，支持Unicode空白）

#### **7. 替换与修改**

- `replace(char oldChar, char newChar)` - 替换所有匹配字符
- `replace(CharSequence target, CharSequence replacement)` - 替换所有匹配序列
- `replaceAll(String regex, String replacement)` - 用正则替换所有匹配
- `replaceFirst(String regex, String replacement)` - 替换第一个匹配

#### **8. 连接与格式化**

- `concat(String str)` - 连接字符串
- `format(String format, Object... args)` - 格式化字符串（静态方法）
- `join(CharSequence delimiter, CharSequence... elements)` - 用分隔符连接多个字符串（静态方法）

#### **9. 类型转换**

- `valueOf(Object obj)` - 将各种类型转换为字符串（静态方法）
- `toCharArray()` - 将字符串转换为字符数组
- `getBytes()` - 将字符串转换为字节数组（使用平台默认编码）
- `getBytes(String charsetName)` - 使用指定编码转换为字节数组

#### **10. 其他常用方法**

- `matches(String regex)` - 判断字符串是否匹配正则表达式
- `repeat(int count)` - 重复字符串指定次数（Java 11+）
- `lines()` - 返回字符串的行流（Java 11+）
- `intern()` - 返回字符串在常量池中的引用

### String、StringBuffer、StringBuilder的区别和联系

| **特性**     | **String**       | **StringBuilder** | **StringBuffer** |
| ------------ | ---------------- | ----------------- | ---------------- |
| **不可变性** | 不可变           | 可变              | 可变             |
| **线程安全** | 是（因不可变）   | 否                | 是（同步方法）   |
| **性能**     | 低（频繁修改时） | 高（单线程）      | 中（多线程安全） |
| **适用场景** | 静态字符串       | 单线程动态字符串  | 多线程动态字符串 |

##  Java 新特性

### Java 8 你知道有什么新特性？

| **特性名称**                 | **描述**                                                     | **示例或说明**                                               |
| ---------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **Lambda 表达式**            | 简化匿名内部类，支持函数式编程                               | `(a, b) -> a + b` 代替匿名类实现接口                         |
| **函数式接口**               | 仅含一个抽象方法的接口，可用 `@FunctionalInterface` 注解标记 | `Runnable`, `Comparator`, 或自定义接口 `@FunctionalInterface interface MyFunc { void run(); }` |
| **Stream API**               | 提供链式操作处理集合数据，支持并行处理                       | `list.stream().filter(x -> x > 0).collect(Collectors.toList())` |
| **Optional 类**              | 封装可能为 `null` 的对象，减少空指针异常                     | `Optional.ofNullable(value).orElse("default")`               |
| **方法引用**                 | 简化 Lambda 表达式，直接引用现有方法                         | `System.out::println` 等价于 `x -> System.out.println(x)`    |
| **接口的默认方法与静态方法** | 接口可定义默认实现和静态方法，增强扩展性                     | `interface A { default void print() { System.out.println("默认方法"); } }` |
| **并行数组排序**             | 使用多线程加速数组排序                                       | `Arrays.parallelSort(array)`                                 |
| **重复注解**                 | 允许同一位置多次使用相同注解                                 | `@Repeatable` 注解配合容器注解使用                           |
| **类型注解**                 | 注解可应用于更多位置（如泛型、异常等）                       | `List<@NonNull String> list`                                 |
| **CompletableFuture**        | 增强异步编程能力，支持链式调用和组合操作                     | `CompletableFuture.supplyAsync(() -> "result").thenAccept(System.out::println)` |

### Lambda 表达式了解吗？

Lambda 表达式是一种简洁的语法，用于创建匿名函数，主要用于简化函数式接口（只有一个抽象方法的接口）的使用。其基本语法有以下两种形式：

- `(parameters) -> expression`：当 Lambda 体只有一个表达式时使用，表达式的结果会作为返回值。
- `(parameters) -> { statements; }`：当 Lambda 体包含多条语句时，需要使用大括号将语句括起来，若有返回值则需要使用 `return` 语句。

可以让代码逻辑更加直观，编写灵活，但也会增加调试难度。

### Java中stream的API介绍一下

Stream是Java 8引入的一套**函数式、声明式**的数据处理API，可以让你用类似SQL语句的方式操作集合数据。**核心理念**是告诉程序"做什么"，而不是"怎么做"。

**Stream的三个特点**

1. **不存储数据**：只是数据的视图，不修改源数据
2. **函数式操作**：每个操作都返回新Stream，可链式调用
3. **延迟执行**：中间操作不立即执行，终端操作才触发计算

stream操作有三个阶段，首先**创建steam**，然后是**中间操作**，比如`filter()`过滤、`map()`映射转换、`limit()`限制数量，最后是终端操作，比如`forEach()`遍历每个元素、`collect()`收集到集合、`toArray()`转化为数组

### Stream流的并行API是什么？

是 ParallelStream。

并行流（ParallelStream）就是将源数据分为多个子流对象进行多线程操作，然后将处理的结果再汇总为一个流对象，底层是使用通用的 fork/join 池来实现，即将一个任务拆分成多个“小任务”并行计算，再把多个“小任务”的结果合并成总的计算结果，适用于大数据量、CPU密集型的任务。

### completableFuture怎么用的？

CompletableFuture是Java 8引入的异步编程工具，实现了`Future`和`CompletionStage`接口，可以：

- 编排多个异步任务
- 处理异步计算结果
- 支持回调函数和异常处理

通过`supplyAsync/runAsync`（有返回值/无返回值）创建异步任务，用`thenApply/thenAccept`（转换结果/消费结果）处理结果，用`thenCompose/thenCombine`（链式依赖/并行合并）组合任务，配合`allOf/anyOf`（等待所有任务完成/任意一个完成）处理多任务，再用`exceptionally/handle`（异常调用/正常异常都调用）处理异常，构建高效的非阻塞应用。

### Java 21 新特性知道哪些？

**新语言特性：**

- **Switch 语句的模式匹配**：该功能在 Java 21 中也得到了增强。它允许在`switch`的`case`标签中使用模式匹配，使操作更加灵活和类型安全，减少了样板代码和潜在错误。例如，对于不同类型的账户类，可以在`switch`语句中直接根据账户类型的模式来获取相应的余额，如`case savingsAccount sa -> result = sa.getSavings();`
- **数组模式**：将模式匹配扩展到数组中，使开发者能够在条件语句中更高效地解构和检查数组内容。例如，`if (arr instanceof int[] {1, 2, 3})`，可以直接判断数组`arr`是否匹配指定的模式。
- **字符串模板（预览版）**：提供了一种更可读、更易维护的方式来构建复杂字符串，支持在字符串字面量中直接嵌入表达式。例如，以前可能需要使用`"hello " + name + ", welcome to the geeksforgeeks!"`这样的方式来拼接字符串，在 Java 21 中可以使用`hello {name}, welcome to the geeksforgeeks!`这种更简洁的写法

**新并发特性方面：**

- **虚拟线程**：一种轻量级并发的新选择。通过共享堆栈的方式，大大降低了内存消耗，同时提高了应用程序的吞吐量和响应速度。可以使用静态构建方法、构建器或`ExecutorService`来创建和使用虚拟线程。
- **Scoped Values（范围值）**：提供了一种在线程间共享不可变数据的新方式，避免使用传统的线程局部存储，促进了更好的封装性和线程安全，可用于在不通过方法参数传递的情况下，传递上下文信息，如用户会话或配置设置。

## 序列化

### 怎么把一个对象从一个jvm转移到另一个jvm?

- **使用序列化和反序列化**：将对象序列化为字节流，并将其发送到另一个 JVM，然后在另一个 JVM 中反序列化字节流恢复对象。这可以通过 Java 的 ObjectOutputStream 和 ObjectInputStream 来实现。适用于**简单的原型验证、极低吞吐量的内部通信**。
- **使用消息传递机制**：利用消息传递机制，比如使用消息队列（如 RabbitMQ、Kafka）或者通过网络套接字进行通信，将对象从一个 JVM 发送到另一个。这需要自定义协议来序列化对象并在另一个 JVM 中反序列化。适用于**异步解耦的消息传递**。
- **使用远程方法调用（RPC）**：可以使用远程方法调用框架，如 gRPC，来实现对象在不同 JVM 之间的传输。远程方法调用可以让你在分布式系统中调用远程 JVM 上的对象的方法。适用于**高性能服务间调用、构建统一的微服务生态**。
- **使用共享数据库或缓存**：将对象存储在共享数据库（如 MySQL、PostgreSQL）或共享缓存（如 Redis）中，让不同的 JVM 可以访问这些共享数据。这种方法适用于**会话共享、分布式锁、缓存、广播通知**。

### 序列化和反序列化让你自己实现你会怎么做?

**首先，我认为序列化的本质，是设计一套严谨的“编解码协议”，将一个内存中复杂的、包含引用关系的对象图，无损地映射为一个线性的、有序的字节流，并且能逆向精准还原。**

基于这个核心，我的实现会分为三个层次：

**第一层是协议设计。** 我会定义一个紧凑的二进制协议。它需要包含类型标记（比如用一个字节区分整数、字符串或对象起始）、长度信息（对于变长数据使用变长编码来节约空间）和具体的值。最关键的是，协议必须能表达**对象间的引用关系**，我会通过为每个首次出现的对象分配唯一ID，后续引用只写ID的方式，来解决循环引用和重复序列化的问题。

**第二层是递归遍历与状态管理。** 序列化过程就像一次深度优先的遍历。我会从一个根对象开始，按照协议将其每个字段（包括嵌套对象）转换为字节。这个过程需要一个“上下文”来记录已序列化对象的ID，避免循环引用导致的无限递归。反序列化则是逆向工程，按协议读取字节流，根据类型标记重建对象，并利用ID映射表准确恢复引用关系，确保反序列化后的对象图拓扑结构完全一致。

**第三层是工业级的增强与防御。** 一个可用的原型之上，必须考虑：**1. 性能**，通过缓存元数据、管理缓冲区来减少反射和IO开销；**2. 版本兼容**，这是最大挑战之一，我会在协议头引入版本号，让反序列化器能智能处理字段的增删（新增字段给默认值，废弃字段选择忽略），实现向前向后兼容；**3. 安全与健壮**，严格校验数据防止恶意构造的流导致内存耗尽，并提供清晰的错误信息。

**序列化框架的真正难度不在于转换字节，而在于如何优雅、高效、安全地处理数据结构的复杂性、版本的变迁以及真实世界的各种边界情况。** 所以一般优先选择成熟框架（如Protobuf）的原因，它们提供了这些复杂问题的最佳实践。

### 将对象转为二进制字节流具体怎么实现?

首先为该对象实现Serializable或Externalizable接口，然后通过序列化对象流来完成序列化和反序列化：

- ObjectOutputStream：通过writeObject(）方法做序列化操作。
- ObjectInputStrean：通过readObject()方法做反序列化操作。

## 设计模式

### volatile和sychronized如何实现单例模式

单例模式的核心是：**一个类在任何情况下，都只有一个全局唯一的实例。**

单用volatile线程不安全，单用sychronized性能差，所以一般用双重检查锁定，同时使用，第一次检查非同步，避免每次都进入同步块的性能问题，第二次检查同步，防止重复创建实例。

### 代理模式和适配器模式有什么区别？

- **目的不同**：代理模式主要关注控制对对象的访问，而适配器模式则用于接口转换，使不兼容的类能够一起工作。
- **结构不同**：代理模式一般包含抽象主题、真实主题和代理三个角色，适配器模式包含目标接口、适配器和被适配者三个角色。
- **应用场景不同**：代理模式常用于添加额外功能或控制对对象的访问，适配器模式常用于让不兼容的接口协同工作。

### 责任链模式使用场景是什么？

责任链模式的使用场景核心就是一个请求需要多个独立的处理逻辑来承接，同时不想让请求发起方和所有处理者产生强关联，让处理流程能灵活调整，整个处理顺序和参与节点能按需改动。

比如接口请求校验，用户调用接口时，可能得先检查登录状态，再验证 token 是否有效，接着确认接口访问权限，最后还要限制请求频率，这些校验逻辑各自独立，而且不同接口需要的校验步骤不一样，比如登录接口只需要验证验证码，查询用户信息的接口得同时过登录和权限校验。要是不用责任链，就得在每个接口里写一堆 if-else 把这些校验串起来，后续想改某个校验规则，所有相关接口都得动，维护起来特别麻烦。

### 介绍一下策略模式和责任链模式，分别用在哪些场景？

都属于行为模式，主要解决代码中`if-else` 或 `switch-case` 逻辑，让系统易于扩展。

- 策略模式：应用于系统需要动态从几种算法中选择一种的情况，比如实现支付功能，而支付有微信、支付宝、银行卡等方式。
- 责任链模式：应用于有多个对象可以处理同一个请求，具体怎么处理要在运行时决定。

## I/O

### **Java怎么实现网络IO高并发编程？**

Java实现网络IO高并发的核心在于用少量线程服务海量连接。传统的一连接一线程（BIO）模型会因线程资源耗尽而崩溃，因此现代方案都转向了非阻塞事件驱动模型。其基石是Java NIO的Selector，它允许单个线程通过轮询来管理多个通道上的IO事件，但这需要手动处理复杂的缓冲区和网络协议。目前生产环境的首选是Netty框架，它基于主从Reactor线程模型，对NIO进行了极致优化和封装，提供了内存池、零拷贝等特性，并内置了丰富的协议支持，让我们能专注于业务逻辑。而未来的趋势是Java 21引入的虚拟线程，它允许我们回归到“一个连接一个虚拟线程”的直观同步编程风格，由于其创建成本极低，能从根本上简化高并发编程，但目前其网络编程生态仍在发展中。

### BIO、NIO、AIO区别是什么？

- BIO（blocking IO）：就是传统的 java.io 包，它是基于流模型实现的，交互的方式是同步、阻塞方式，也就是说在读入输入流或者输出流时，在读写动作完成之前，线程会一直阻塞在那里，它们之间的调用是可靠的线性顺序。
- NIO（non-blocking IO） ：Java 1.4 引入的 java.nio 包，提供了 Channel、Selector、Buffer 等新的抽象，可以构建多路复用的、同步非阻塞 IO 程序，同时提供了更接近操作系统底层高性能的数据操作方式。
- AIO（Asynchronous IO） ：是 Java 1.7 之后引入的包，是 NIO 的升级版本，提供了异步非堵塞的 IO 操作方式，是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。

### NIO是怎么实现的？

NIO是一种同步非阻塞的IO模型，实现高并发的核心在于它用事件驱动机制代替阻塞的监视事件。关键在于三个组件，将连接抽象为可非阻塞读写的channel，所有数据操作都要经过的Buffer，以及能够只用一个线程轮询的成千上万个Channel上IO事件的Selector。整个工作流程是一个线程在Selector上等待，当有Channel事件就绪时，Selector会返回这批事件，线程随后遍历这些事件，并使用Buffer去和对应的Channel交换数据，实现用极少线程管理海量网络连接。

### 你知道有哪个框架用到NIO了吗？

**Netty。**

Netty在原生NIO的基础上，主要做了四层关键的增强和封装：

- 提供了**开箱即用的高效线程模型（如主从Reactor模式）**，解决了需要手动设计和管理复杂多线程的问题；
- 通过**内置的内存池和零拷贝机制**优化了ByteBuffer的内存分配与回收，大幅提升了性能并减少了GC压力；
- 将Channel、Selector和事件处理抽象成清晰的 **Pipeline和ChannelHandler链**，让开发者能以模块化的方式处理业务逻辑，避免了在NIO中手动循环处理事件和管理状态的复杂性；
- **内置了如HTTP、WebSocket等多种协议的编解码器**，解决了NIO需要手动处理网络协议（如粘包拆包）的繁琐问题。简而言之，Netty将NIO的底层组件和复杂细节封装成了一套高性能、易用且功能完备的网络编程框架。

## 其他

### 有一个学生类，想按照分数排序，再按学号排序，应该怎么做？

可以用Comparable接口来实现，在该学生类里实现Comparable接口，重写compareTo，实现排序逻辑。

### Native方法解释一下

native关键字是Java语言中的一种声明，用于标记一个方法的实现将在外部定义。

是通过**Java本地接口（JNI）**来调用由C、C++或汇编等语言编写、并编译为本地操作系统库（如 `.dll` 或 `.so` 文件）的代码。它的核心价值在于**突破JVM限制，直接与操作系统底层交互或复用成熟的本地代码库**，主要应用于执行对性能要求极高的操作（如大量数学计算、图形处理）、访问特定平台的系统功能（如硬件设备、操作系统原生API），或者利用现有的非Java语言库。由于它绕过了JVM的直接管理，因此也带来了平台依赖、内存管理复杂（需手动防止内存泄漏）和潜在安全风险等挑战；Java标准库中像 `Object.hashCode()`、`Thread.start()` 等涉及底层资源管理的方法，其底层实现就是Native方法。

### Java 进程是怎么跟操作系统交互的？

本质上通过JVM来完成

当Java代码（如new对象、读写文件、创建线程）被执行时，JVM会通过其本地方法接口和内部实现，将通用指令转换为特定操作系统的原生指令，例如在Linux上，内存分配可能调用 `mmap/brk`，创建线程调用 `pthread_create`，而网络IO则通过 `epoll` 等系统调用实现。在这一过程中，**JVM自身也通过向操作系统申请和调度内存、CPU等物理资源来运行**。所有需要操作硬件或核心资源的请求，最终都必须由JVM代理，从用户态切换到内核态执行。因此，**Java的“一次编写，到处运行”能力，正是由JVM针对不同平台适配并封装了这些底层差异来实现的**，而性能优化的关键之一就在于减少这种状态切换的开销。
