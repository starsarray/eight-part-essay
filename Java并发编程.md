## 多线程

### Java的内存模型（JMM）介绍一下

JMM规定了所有变量都存在主内存(Main Memory)中。
但每个线程都有自己的工作内存(Working Memory)（类比CPU缓存）。

- 读数据：线程必须先把变量从主内存拷贝到自己的工作内存，才能使用。
- 写数据：线程只能改自己工作内存里的副本，改完后再刷回主内存。
- 隔离性：线程A看不到线程B工作内存里的数据，它们只能通过主内存来“传话”。

JMM有三大特点：

- 原子性(Atomicity)
  - 定义：一个操作要么全做，要么全不做，不能被中断。
  - 问题：i++就不是原子的（读-改-写三步）。
  - 保障：synchronized

- 可见性(Visibility)
  - 定义：一个线程改了数据，其他线程能立马看见。
  - 问题：线程A改了flag=true，但还在自己缓存里没刷回去；线程B读主内存，还是false。
  - 保障：volatile,synchronized

- 有序性(Ordering)
  - 定义：程序按照代码写的顺序执行。
  - 问题：编译器和CPU为了优化，会进行指令重排序(Instruction Reordering)。单线程没问题，多线程下可能会乱套（比如单例模式的双重检查锁）。
  - 保障：happens-before原则，使用volatile,synchronized来保障

###  Java多线程是什么？需要注意什么？

是指在一个Java程序中同时运行多个线程，这些线程共享程序的内存空间，但有各自的栈和程序计数器，能同时执行不同的任务。

需要注意线程安全、线程间通信和线程的创建和销毁成本。

### Java里面的线程和操作系统的线程一样吗？

是一样的，Java底层会调用pthread_create 来创建线程，是 1 对 1 的线程模型。

### 使用多线程要注意哪些问题？

原子性、可见性、有序性

### 保证数据的一致性有哪些方案呢？

- **事务管理**：使用数据库事务来确保一组数据库操作要么全部成功提交，要么全部失败回滚。通过ACID（原子性、一致性、隔离性、持久性）属性，数据库事务可以保证数据的一致性。
- **锁机制**：使用锁来实现对共享资源的互斥访问。在 Java 中，可以使用 synchronized 关键字、ReentrantLock 或其他锁机制来控制并发访问，从而避免并发操作导致数据不一致。
- **版本控制**：通过乐观锁的方式，在更新数据时记录数据的版本信息，从而避免同时对同一数据进行修改，进而保证数据的一致性。

### 线程的创建方式有哪些?

- 继承java.lang.Thread类
  - 优点：访问简单，直接使用this
  - 缺点：不能再继承其他类
- 实现Runnable接口
  - 优点：只实现（implements）了这个接口，还可以继承（extends）其他类
  - 缺点：编程稍微复杂，访问必须用Thread.currentThread()方法。
- 实现Callable接口与FutureTask
  - 特点：与Runnable一样，不过有返回值，可以抛出异常，但需要包装进一个FutureTask，因为Thread类的构造器只接受Runnable参数，而FutureTask实现了Runnable接口。
- 线程池
  - 优点：可以重用预先创建的线程，避免了线程创建和销毁的开销。
  - 缺点：增加了程序复杂度，当涉及线程池参数调整和故障排查时，错误的配置会导致死锁、资源耗尽等问题，这些问题的诊断和修复可能较为复杂。

### 如何停止一个线程的运行?

**1. 异常法停止（协作式中断）**

- **调用者线程**：调用 `targetThread.interrupt()`，将目标线程的**中断标志设为true**。
- **目标线程**：在其 `run()` 方法中，**需主动检查** `Thread.interrupted()` 或 `isInterrupted()` 状态。如果发现被中断，可以**选择抛出 `InterruptedException` 或进行其他处理**来结束运行。这是**协作式**的，目标线程掌握控制权。

**2. 在沉睡/阻塞中停止**

- **调用者线程**：在目标线程因调用 `sleep()`、`wait()`、`join()` 等方法而**阻塞时**，调用 `targetThread.interrupt()`。
- **目标线程**：会**立即**收到 `InterruptedException` 异常，从而跳出阻塞状态。这是中断机制最典型、最有效的用途之一。

**3. `stop()` 暴力停止（已废弃）**

- **调用者线程**：调用 `targetThread.stop()`。
- **目标线程**：**无论执行到哪一行代码，都会被强制、立即停止**，并释放所有锁。这会导致对象状态损坏、清理工作无法完成等严重后果，因此**绝对禁止使用**。

**4. 使用return停止（协作式中断的另一种响应）**

- **调用者线程**：同样调用 `targetThread.interrupt()` 设置中断标志。
- **目标线程**：在 `run()` 方法中检查到中断状态后，**选择通过 `return` 语句退出方法**来终止线程。这是一种简单、干净的响应方式。

### 调用 interrupt 是如何让线程抛出异常的?

每个线程都有一个中断状态标志，初始为false。当线程A调用 `threadB.interrupt()` 时，核心是设置threadB的中断状态为true，而threadB如何响应完全取决于它**自身所处的状态和代码逻辑**：

1. **如果threadB正阻塞在如 `sleep()`、`wait()`、`join()` 这类可中断的阻塞方法上**，它会立即被唤醒，同时JVM会**清除其中断状态并抛出 `InterruptedException`**。这是中断机制最直接、最高优先级的响应方式。
2. **如果threadB正在正常运行**，`interrupt()` 仅会设置其中断状态，在该被中断的线程中稍后可通过轮询中断状态来决定是否要停止当前正在执行的任务。



### Java线程的状态有哪些？

| 线程状态      | 解释                                                         |
| ------------- | ------------------------------------------------------------ |
| NEW           | 尚未启动的线程状态，即线程创建，**还未调用start方法**        |
| RUNNABLE      | **就绪状态**（调用start，等待调度）+**正在运行**             |
| BLOCKED       | **等待监视器锁**时，陷入阻塞状态                             |
| WAITING       | 等待状态的线程正在**等待**另一线程执行特定的操作（如notify） |
| TIMED_WAITING | 具有**指定等待时间**的等待状态                               |
| TERMINATED    | 线程完成执行，**终止状态**                                   |

### sleep 和 wait的区别是什么？

- **所属分类的不同**：sleep 是 `Thread` 类的静态方法，可以在任何地方直接通过 `Thread.sleep()` 调用，无需依赖对象实例。wait 是 `Object` 类的实例方法，这意味着必须通过对象实例来调用。
- **锁释放的情况**：`Thread.sleep()` 在调用时，线程会暂停执行指定的时间，但不会释放持有的对象锁。也就是说，在 `sleep` 期间，其他线程无法获得该线程持有的锁。`Object.wait()`：调用该方法时，线程会释放持有的对象锁，进入等待状态，直到其他线程调用相同对象的 `notify()` 或 `notifyAll()` 方法唤醒它
- **使用条件**：sleep 可在任意位置调用，无需事先获取锁。 wait 必须在同步块或同步方法内调用（即线程需持有该对象的锁），否则抛出 `IllegalMonitorStateException`。
- **唤醒机制**：sleep 休眠时间结束后，线程 自动恢复 到就绪状态，等待CPU调度。wait 需要其他线程调用相同对象的 `notify()` 或 `notifyAll()` 方法才能被唤醒。`notify()` 会随机唤醒一个在该对象上等待的线程，而 `notifyAll()` 会唤醒所有在该对象上等待的线程



















































## 并发安全

### 介绍一下AQS