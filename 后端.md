### AOP

Aspect Oriented Programming（面向切面编程、面向方面编程）

#### 开发步骤

1. 导入依赖

2. 编写AOP程序

   新建Apsect切面类、类上打上***@Aspect***注解、方法打上通知类型注解

#### 通知类型

1. ***@Around***：环绕通知，此注解标注的通知方法在目标方法前、后都被执行
2. ***@Before***：前置通知，此注解标注的通知方法在目标方法前被执行
3. ***@After*** ：后置通知，此注解标注的通知方法在目标方法后被执行，无论是否有异常都会执行
4. ***@AfterReturning***： 返回后通知，此注解标注的通知方法在目标方法后被执行，有异常不会执行
5. ***@AfterThrowing*** ： 异常后通知，此注解标注的通知方法发生异常后执行

**注意：**

1. ***@Around***环绕通知需要自己调用 ProceedingJoinPoint.proceed() 来让原始方法执行，其他通知不需要考虑目标方法执行
2. ***@Around***环绕通知方法的返回值，必须指定为Object，来接收原始方法的返回值。

***@PointCut***：将公共的切点表达式抽取出来，在***@Around***里引用，提高复用性

#### 通知顺序

在切面类上加上***@Order***注解，数字小的先执行

#### 切入点表达式

作用：决定项目里哪些方法需要加入通知

**execution**：根据方法的签名来匹配

**@annotation**:根据注解匹配

![image-20260108150852707](C:\Users\Star\AppData\Roaming\Typora\typora-user-images\image-20260108150852707.png)



### 会话技术

#### Cookie：

​	**优点：**HTTP协议支持的技术

​	**缺点：**移动端无法使用、不安全、不能跨域

#### Session：

​	**优点：**存储在服务端，安全

​	**缺点：**服务器集群无法直接使用、Cookie的缺点

#### 令牌：

​	**优点：**支撑PC、移动端；解决集群认证问题；减轻服务器存储压力

​	**缺点：**需要自己实现



### JWT令牌(JSON  Web Token)

1. **Header**(头），记录令牌类型、签名算法等。 例如：`{"alg":"HS256","type":"JWT"}`
2. **Payload**(有效载荷），携带一些自定义信息、默认信息等。 例如：`{"id":"1","username":"Tom"}`
3. **Signature**(签名），将header、payload融入，并加入指定秘钥，通过指定签名算法计算而来。防止Token被篡改、确保安全性。

工程实现：引入**jjwt**依赖用`Jwts.builder()`和`Jwts.parser()`执行令牌生成和校验



### 过滤器Filter（拦截所有资源）

1. 定义一个类实现Filter接口，重写三个方法***`init、doFilter、destroy`***

2. 类上加***@WebFilter***注解配置拦截路径、引导类加上***@ServletComponentScan***开启Servlet组件支持



### 拦截器Interceptor（拦截Spring环境中的资源）

1. 实现***HandlerInterceptor***接口，重新三个方法***`preHandle、postHandle、afterHandle`***

2. 创建配置类**WebConfig**，实现***WebMvcConfigurer***，重写***`addInterceptors`***



### **SpringBoot配置优先级**

命令行参数>java系统属性 》application.properites>yml>yaml



#### **bean作用域**（Spring支持5种，其他三个web环境生效）

默认为***singleton***（单例），有状态设置为***prototype***，比如每次请求**保存**当前请求的操作次数

通过注解***@Scope***设置作用域，可以通过***@Lazy***延迟初始化创建bean



#### **第三方Bean**

通过在**启动类**或者**配置类**用***@Bean***配置为Bean对象，bean名称默认为方法名



### SpringBoot原理

1. 起步依赖：就是Maven的**依赖传递**
2. 自动配置：Spring项目启动后，一些**配置类、bean**对象就会**自动存入**IOC容器中，不需要手动声明

#### 自动配置实现方案(推荐b)

a. 通过***@ComponentScan***注解扫描指定的包

b. 通过***@Import***注解将其导入到IOC容器中(四种常见方式)普通类、配置类、ImportSelector实现类、@EnableXxx

#### 源码跟踪

***@SpringBootApplication***注解包含：

1. ***@SpringBootConfiguration***：该注解与 ***@Configuration*** 注解作用相同，用来声明当前也是一个配置类。
2. ***@ComponentScan***：组件扫描，默认扫描当前引导类所在包及其子包。
3. ***@EnableAutoConfiguration***：SpringBoot实现自动化配置的核心注解。

***@EnableAutoConfiguration***包含***@Import***注解，会根据一定的条件注册这些bean对象

***@Conditional*** 本身是一个父注解，派生出大量的子注解： 

1. ***@ConditionalOnClass***：判断环境中是否有对应字节码文件，才注册bean到IOC容器。 

2. ***@ConditionalOnMissingBean***：判断环境中没有对应的bean（类型 或 名称） ，才注册bean到IOC容器。 

3. ***@ConditionalOnProperty***：判断配置文件中有对应属性和值，才注册bean到IOC容器。

#### 自定义starter

**步骤**：

1. 创建aliyun-oss**-spring-boot-starter**模块
2. 创建aliyun-oss**-spring-boot-autoconfigure**模块，在starter中引入该模块
3. 在aliyun-oss-spring-boot-autoconfigure模块中的定义自动配置功能，并定义自动配置文件 META-INF/spring/xxxx.imports

### Maven高级

#### 分块设计

#### 继承

1. 概念：继承描述的是两个工程间的关系，与java中的继承相似，子工程可以继承父工程中的配置信息，常见于依赖关系的继承。
2. 作用：简化依赖配置、统一管理依赖
3. 实现：<parent> … </parent>

**继承关系**

1. 创建maven模块tlias-parent，该工程为父工程，设置打包方式pom(默认jar)。
2. 在子工程的pom.xml文件中，配置继承关系。
3. 在父工程中配置各个工程共有的依赖（子工程会自动继承父工程的依赖）

**版本锁定**

在maven中，可以在父工程的pom文件中通过 <dependencyManagement> 来统一管理依赖版本。可在<properties>里自定义自定义属性/引用属性，更直观管理版本信息。

#### 聚合

1. 聚合：将多个模块组织成一个整体，同时进行项目的构建。
2. 聚合工程 ：一个不具有业务功能的“空”工程（有且仅有一个pom文件）
3. 作用：快速构建项目（无需根据依赖关系手动构建，直接在聚合工程上构建即可）
4. 实现：maven中可以通过 <modules> 设置当前聚合工程所包含的子模块名称

#### 私服

解决团队内部的资源共享与资源同步问题

1. 设置私服的访问用户名/密码（settings.xml中的servers中配置）
2. IDEA的maven工程的pom文件中配置上传（发布）地址
3. 设置私服依赖下载的仓库组地址（settings.xml中的mirrors、profiles中配置）