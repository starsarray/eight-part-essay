# 进程和线程

## 进程和线程的区别是什么？

进程是资源分配和调度的最小单位

线程是程序执行的最小单位

一个进程可以运行多个线程，多个线程共享一块内存空间

区别：

- 资源开销	
- 通信与同步
- 安全性

## 并行和并发有什么区别？

- 并行
  并行是同一时刻执行多个任务，对CPU来说，是指在多个核心上执行不同的任务。
- 并发
  并发是在某个时间段内执行多个任务。比如对单核处理器来说，并发就是通过分配时间片，让不同任务交替往复地执行下去。

## 解释一下用户态和核心态？

核心态（内核态）：

- CPU可以执行所有指令，包括特权指令

- 可以访问所有内存空间和硬件资源

- 操作系统内核运行在此模式下

用户态：

- CPU只能执行非特权指令

- 只能访问受限的内存空间（用户空间）

- 普通应用程序运行在此模式下

## 进程调度算法

### 1. **先来先服务（FCFS, First-Come, First-Served）**

**定义**：

- **FCFS** 是按进程到达的顺序进行调度，先来先执行。

**特点**：

- 非抢占式，即一旦进程开始执行，它将一直执行，直到完成。
- 调度简单，容易实现。
- **问题**：容易导致“饥饿”现象或**长任务阻塞短任务**，也容易引起 **队列效应**，即进程等待时间较长，导致 **平均等待时间** 高。

**适用场景**：

- 适用于进程执行时间较为均匀、没有突发较长进程的情况，或者任务间的执行时间差距较小的系统。

### 2. **短作业优先（SJF, Shortest Job First）**

**定义**：

- **SJF** 是一种非抢占式的调度算法，优先选择执行运行时间最短的进程。通过预测每个进程的执行时间来确定调度顺序。

**特点**：

- 如果执行时间已知，能够使 **平均等待时间最小**，即优化了系统的响应时间。
- 该算法会导致 **长进程饥饿**，如果总是有新的短进程到来，长进程就可能一直无法执行。
- 在实际情况中，预测每个进程的执行时间通常很困难。

**适用场景**：

- 对于已知作业长度、进程执行时间比较稳定的系统，或者执行任务相对较短的场景，SJF 可以发挥较好性能。

### 3. **最短剩余时间优先（SRTF, Shortest Remaining Time First）**

**定义**：

- **SRTF** 是抢占式的 **SJF** 算法，它选择剩余执行时间最短的进程。若一个新进程到来时其剩余时间比当前正在执行的进程短，则会抢占 CPU 执行。

**特点**：

- 与 SJF 相似，但具有抢占式特性。
- 可以有效地减少平均等待时间。
- 与 SJF 一样，可能导致 **长进程饥饿**，并且对于未知的执行时间预测存在挑战。

**适用场景**：

- 适用于已知剩余执行时间，且优先调度短任务的系统。

### 4. **优先级调度（Priority Scheduling）**

**定义**：

- 进程根据优先级进行调度。优先级高的进程先执行，优先级低的进程后执行。
- 优先级可以根据不同的标准设定，例如任务的重要性、所需资源等。

**特点**：

- 可实现抢占式或非抢占式调度。抢占式优先级调度在运行过程中，若一个新进程的优先级高于当前执行进程，则会抢占 CPU。
- 可能导致 **低优先级进程饥饿**，特别是在长时间不调整优先级的情况下。
- 动态优先级调度可以通过 ** aging 算法**（逐渐提高低优先级进程的优先级）来解决饥饿问题。

**适用场景**：

- 适用于多种任务重要性不同的场景，例如一些实时性较强的任务需要优先执行，而其他任务则可以稍后处理。

### 5. **轮转法（RR, Round Robin）**

**定义**：

- **RR** 是一种时间片轮转的调度算法。每个进程分配一个固定的时间片，当进程的时间片用尽后，它会被放回队列的末尾，等待下一次轮到它继续执行。

**特点**：

- 抢占式算法，每个进程的执行时间受到限制（即时间片的长度）。
- 适合 **响应时间要求较高** 的系统，能保证各个进程公平地获得 CPU 资源。
- 但如果时间片设置不合理（过短或过长），可能会导致 **过多的上下文切换**，从而增加开销。

**适用场景**：

- 适用于交互式系统（如操作系统的命令行和图形界面），或者对响应时间有较高要求的系统，如时间共享系统。

### 6. **多级反馈队列调度（Multilevel Feedback Queue）**

**定义**：

- MLFQ

  是一种结合多级队列与优先级调度的**抢占式**策略。在 MLFQ 中，当新进程到达时，它会被放入最高优先级的队列中。每个队列都对应一个时间片，进程会按队列中的时间片运行。当进程用完当前队列的时间片时：

  - 如果它还未完成，则会被移到下一个低优先级队列中，进入新的队列后，它的执行时间片通常会变长。
  - 如果进程在时间片内完成任务，它将从队列中移除。

**特点**：

- 结合了 **FCFS**、**SJF** 和 **优先级调度** 的优点，可以有效避免饥饿问题，同时尽量减少长任务的等待时间。
- 动态调整进程的优先级，使得短任务能够更快执行，长任务能逐步降级。
- 算法设计复杂，涉及多个队列和多次调度策略。

**适用场景**：

- 多任务系统或负载较重的系统，可以根据实际负载自动调整调度策略，保证较好的响应性和公平性。

### 总结与选择：

- 对于 **实时系统**，需要保证任务按时完成，常用的调度算法包括 **优先级调度** 和 **最短作业优先**。
- 对于 **交互式系统**，如多任务桌面操作系统，常用 **轮转法** 和 **多级反馈队列调度**。
- 对于需要 **平衡效率和公平性** 的情况， **多级反馈队列** 是一种比较理想的选择。

## 进程间有哪些通信方式？

1. 管道：内核里的一串缓存，进程间通信通过使用fork创建子进程复制父进程的文件描述符

   1. 功能：将前一个命令的输出作为后一个命令的输入
   2. 分类：
      1. 匿名管道「|」：通信范围在父子间的进程
      2. 命名管道（FIFO）：在不相关的进程中也能相互通信
   3. 效率低，不适合进程间频繁的交换数据

2. 消息队列：保存在内核中的消息链表，不适合较大数据的传输，存在用户态和内核态之间的数据拷贝开销。

   1. 通信不及时
   2. 附件大小有限制

3. 共享内存：拿出一块虚拟地址空间映射到相同的物理内存中

4. 信号量：是一个整型计数器，主要用于实现进程间的互斥和同步，而不是用于缓存进程间通信的数据

   1. 控制方式：
      1. p操作：信号量-1，如果结果<0资源被占用进程需要阻塞，反之可以正常执行，进入共享资源前
      2. v操作：信号量+1，如果<=0说明有阻塞，会唤醒运行，反之没有，离开共享资源后

5. 信号：异常情况下的工作模式，需要用信号的方式来通知进程，是进程间通信机制中唯一的异步通信机制 5. 用户进程对信号的处理方式：1.执行默认操作 2.捕捉信号 3.忽略信号

6. Socket：跨网络和不同的主机上的进程之间通信

   ```java
   int socket(int domain, int type, int protocal)
   ```

## 什么是孤儿进程和僵尸进程，如何处理它们？

#### 孤儿进程

父进程意外终止，而它的子进程仍然运行；操作系统会自动接管孤儿进程，使其成为init的子进程，它的退出状态由init负责。

**影响：**通常无害，但可能造成意外的后台任务持续运行、资源占用或者逻辑不一致。

#### 僵尸进程

当子进程终止，但其父进程并没有调用获取子进程的退出状态时，子进程的进程表仍然留在系统中。

**影响：**大量僵尸进程会耗尽进程表资源，影响系统创建新进程。

##### 处理方法

调用wait或 waitpid，对子进程的退出状态回收

## 进程有几种状态，它们之间是如何转换的？

新建、就绪、运行、阻塞（等待）、结束

#### 1. **就绪 → 运行**

- 当调度程序选择一个就绪进程，并为其分配 CPU 时，进程从就绪状态转变为运行状态。

#### 2. **运行 → 就绪**

- 当正在运行的进程因为时间片耗尽或者被抢占而暂停执行时，会返回到就绪状态。

#### 3. **运行 → 阻塞**

- 当进程需要等待某个事件时，例如等待 I/O 完成、等待资源、等待信号等，会从运行状态转变为阻塞状态。

#### 4. **阻塞 → 就绪**

- 当阻塞的事件完成时，例如 I/O 操作结束、等待的资源可用等，阻塞进程会重新进入就绪状态。

## 什么是作业调度和进程调度，它们之间有什么区别？

- 作业调度是长程调度，决定哪些作业被接纳为进程进入内存，控制并发度与吞吐。
- 进程调度是短程调度，决定就绪队列里当前哪个进程占用CPU，关注响应、公平与利用率。
- 两者层级、对象、目标、时机不同；现代交互式OS更侧重进程调度，作业调度在批处理/集群更常见。

作业调度侧重系统吞吐与并发，进程调度侧重CPU利用与交互响应。

## 解释一下操作系统的信号机制，以及它的作用？

**信号机制**是操作系统提供的一种进程间通信和事件通知机制，用于向进程传递异步事件。信号可以由操作系统或其他进程发送，并由目标进程处理。其主要作用是：

1. **通知事件**：如进程中断、定时器到期或硬件异常。
2. **进程控制**：如终止、暂停、继续或重启进程。
3. **进程间通信**：让一个进程向另一个进程发送特定的通知或指令。

## 解释一下操作系统的中断机制，以及它的作用？

中断机制是当发生重要事件时，CPU立即打断当前执行，切入内核态运行对应的“中断处理程序”，处理完再恢复原程序的机制。

**作用：**支撑抢占式多任务、快速I/O响应、错误与异常处理、系统调用入口、节能唤醒与提升并发，是事件驱动操作系统的核心基础。



# 互斥与同步

## 什么是银行家算法，它是如何解决死锁问题的？

#### 简要回答

1. 银行家算法的概念：
   - 一种用于**动态资源分配**的死锁避免算法。其核心思想是：**对于每次资源申请，系统都要实时判断其是否有死锁风险，如果存在风险，就拒绝该申请；仅在资源分配后系统仍处于安全状态时，才允许分配资源**，从而**避免死锁**。
2. 银行家算法的实现：
   - **安全状态检查**：每次分配资源前，模拟分配后的系统状态，判断系统是否存在一个 **安全序列**（所有进程能按顺序获得所需资源并完成）。
   - **动态决策**：若安全状态成立，则正式分配资源；若无法找到安全序列，则拒绝资源请求，防止系统进入可能导致死锁的状态。

**银行家算法的数据结构：**

- 系统可用资源向量`Available[m]`：表示系统中每种资源的可用数量，随着系统资源分配与回收情况的变动而动态变化。
- 最大需求矩阵`Max[n][m]`：表示系统中 n 个进程中每个进程对 m 类资源的最大需求量。
- 分配矩阵`Allocation[n][m]`：表示当前每个进程占有的各类资源数量。
- 需求矩阵`Need[n][m]`：表示进程完成任务还需要每种资源的数量；`Need[i][j] = Max[i][j] - Allocation[i][j]`。

**银行家算法的思想**：

设Request i 为进程 Pi 的请求向量，当 Pi 申请一个资源时，系统进行以下检查：
① 先判断进程需求资源数量与它申报的最大需求数量
② 判断进程需求资源数量与系统可用资源数量
③ 系统**试图**为进程 Pi 分配资源，并更新以下数据结构中的值：

```java
Available[j] = Abailable[j] - Request i [j];
Allocation[i][j] = Allocation[i][j] + Request i [j];
Need[i][j] = Need[i][j] - Request i [j];
```

④ 系统通过**安全性算法**检查为该进程分配资源后，是否仍处于安全状态。如果系统是安全的，资源就被正式分配给进程 Pi；否则，终止分配，系统回退到原来的资源分配状态，并让进程 Pi 继续等待。

银行家算法的安全性检查：

- ① 定义两个向量：

- **工作向量Work[m]** 表示系统中可用于维持进程运行的各类资源的数量，在安全性算法执行前，令 Work = Available；

- **Finish[n]** 表示系统中是否有足够的资源分配给该进程，以使其运行完毕，初始化 **Finish[i] = FALSE**，当有足够的空闲资源分配给进程 Pi 时，令**Finish[i] = TRUE**。

- ② 在进程集合中找到一个进程，使其满足条件——`Finish[i] == FALSE && Need[i][j] ≤ Work[j]`，如果能找到，则执行步骤 ③，否则执行步骤 ④。

- ③ 若进程满足步骤 ② 中的条件，说明当进程 Pi 被分配资源后，它可以顺利运行完毕，并释放其占有的资源，以供其他进程使用，这时应该执行如下指令：

  ```
  Work[j] = Work[j] + Allocation[i][j];
  Finish[i] = TRUE;
  继续进行步骤 ② (循环执行步骤2，直到所有进程都满足 Finish[i] == TRUE，或者其中一个进程不满足步骤2中的判断条件);  
  ```

- ④ 如果 **Finish[i] == TRUE** 对于进程集合中的每个进程都满足，说明系统处于安全状态，允许此次资源分配；否则，系统处于不安全状态。

##### 银行家算法的优缺点

1. 优点：
   - 严格避免死锁，保证系统安全。
   - 资源利用率高于死锁预防策略（如一次性分配）。
2. 缺点：
   - **静态需求假设**：进程需预先声明最大资源需求，现实中难以动态调整。
   - **计算开销大**：每次请求需遍历所有进程，时间复杂度为 O(n²)。
   - **不适用于不可抢占资源**：如打印机、独占设备。

## 解释一下进程同步和互斥，以及如何实现进程同步和互斥？

### 同步：

定义：让进程之间按既定的先后关系协调运行，保证正确的执行顺序与协作。

实现：用计数信号量/条件变量/事件或消息队列明确先后关系；条件不满足时阻塞等待，满足后通知唤醒。

### 互斥：

多个进程不能同时访问共享资源，避免竞争条件和数据不一致问题。

实现：用互斥锁/二值信号量/文件锁保护临界区，进入前加锁，退出时解锁；临界区短小、避免死锁。

- 锁（Mutex/互斥锁）：进入临界区前“加锁”，退出时“解锁”；锁只有一个持有者，保障互斥。
- 信号量（Semaphore）：一个计数器，控制可并发进入的数量；二值信号量（0/1）可当互斥锁用；计数信号量（>1）用于同步多个可用资源或多路并发。
- 管程/监视器（Monitor）：把共享状态封装在对象里，入口方法隐式加锁；配合条件变量（Condition）做“等待/通知”实现同步。
- 条件变量（Condition）：进程在某条件不满足时等待；条件满足时被唤醒（signal），实现“先后关系”的同步。
- 原子指令（硬件支持）：如 Test-and-Set、Compare-and-Swap（CAS），用来实现高效的锁与无锁结构（解释：这些指令一次性完成“读+比较+写”，不可被打断）。
- 软件算法（教学用）：如 Peterson 算法，仅适用于两个参与者，依赖严格的内存可见性与顺序保证。

## 什么是死锁，如何预防死锁？

一、什么是死锁？

**死锁（Deadlock）** 是指两个或多个进程在执行过程中，因为争夺资源而造成的一种互相等待的现象，若无外力干预，它们都将无法继续执行。

二、产生死锁的四个必要条件（操作系统理论）

1. **互斥条件（Mutual Exclusion）** 每个资源要么已经分配给了一个进程，要么就是可用的（不可同时被两个以上进程使用）。
2. **请求与保持条件（Hold and Wait）** 一个进程因请求资源而阻塞时，对已获得的资源保持不放。
3. **不剥夺条件（No Preemption）** 进程已经获得的资源，在未使用完之前，不能强行剥夺。
4. **循环等待条件（Circular Wait）** 存在一种进程资源的循环等待链，使得每个进程都等待下一个进程所占有的资源。

三、如何预防死锁？

1. **破坏必要条件**

- **破坏互斥条件**：不太现实，部分资源本身就是不能共享的（如打印机）。
- **破坏请求与保持**：一次性申请所有资源（代价高，不灵活）。
- **破坏不剥夺条件**：当某一进程请求资源失败时，主动释放已占资源。
- **破坏循环等待**：对所有资源统一编号，进程必须按照编号递增顺序请求资源。

1. **避免死锁（动态检测）**

- 使用 

  银行家算法

  （Banker's Algorithm）：

  - 在资源分配前模拟是否会导致死锁。
  - 只有在系统处于安全状态下才允许资源分配。

1. **死锁检测与恢复**

- 允许系统进入死锁状态，定期检测是否存在死锁。
- 检测后通过撤销进程、抢占资源等方式进行恢复。
